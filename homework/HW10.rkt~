;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname content) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))

;; Usual Instructions:
;; 1. Do not create, modify or delete any line that begins with ";;!". These are
;;    markers that we use to segment your file into parts to facilitate grading.
;; 2. You must follow the _design recipe_ for every problem. In particular,
;;    every function you define must have at least three check-expects (and
;;    more if needed).
;; 3. You must follow the Style Guide:
;;    https://pages.github.khoury.northeastern.edu/2500/2024F/style.html
;; 4. You must submit working code. In DrRacket, ensure you get no errors
;;    when you click Run. After you submit on Gradescope, you'll get instant
;;    feedback on whether or not Gradescope can run your code, and your code must
;;    run on Gradescope to receive credit from the autograder.
;; 5. On some problems, you can get automated feedback on your in-progress work
;;    from FeedBot, a system developed by the course staff. When you submit your
;;    assignment, you will see a link to the FeedBot report along with the autograder
;;    feedback. Only a certain number of submissions will get this, and submissions
;;    close together will not receive the feedback.

;;! HW10
;; Consider the following data definition for binary trees:

(define-struct leaf [val])
(define-struct node [left right])

;; A [BinTree-of X] is one of:
;; - (make-leaf X)
;; - (make-node [BinTree-of X] [BinTree-of X])
;; Interpretation - a binary tree of values of type X which is either:
;; - a leaf containing a value
;; - or a node containing two binary trees

;; The goal of this homework will be to write abstractions for working with
;; binary trees, similar to the list abstractions you are familiar with.

;;! Problem 1

;;! Part A
;; Finish the data design for BinTree by writing examples and a template.

;;!! IMPORTANT: Write your response BELOW this line:


;;! Part B
;;
;; Design a function called tree-zero that takes a binary tree and replaces all
;; leaf values with 0; the structure of the tree should remain the same.

;;!! IMPORTANT: Write your response BELOW this line:


;;! Part C
;;
;; Design a function tree-contains? that takes a String and a [BinTree-of
;; String] that returns whether the String exists as a leaf.

;;!! IMPORTANT: Write your response BELOW this line:


;;! Part D
;;
;; Design a function tree-sum that takes a [BinTree-of Number] and returns the
;; sum of all the numbers in the tree.


;;!! IMPORTANT: Write your response BELOW this line:



;;! Part E
;;
;; While trees have more structure, like lists, they still contain elements. To
;; demonstrate this similarity, design a function called tree-flatten that takes
;; a binary tree and converts it into a list. When flattening a node, the resulting list
;; should contain all leaves on the left side of the node before the leaves
;; on the right side of the node.

;; For example, the flattening the tree below should result in `(list 1 2 3 4 5 6)`:
;;           *
;;          / \
;;         *   6
;;        / \
;;       1   *
;;          / \
;;         *   5
;;        / \
;;       *   4
;;      / \
;;     2   3

;;!! IMPORTANT: Write your response BELOW this line:


;;! Part F

;; INTERPRETIVE QUESTION
;;
;; In some families -- maybe including yours -- people want to be able to
;; understand who their ancestors are and how they're related to their them.
;;
;; Family trees can be useful for that purpose. Family trees represent familial
;; relationships in certain ways. For example, a node represents a parent, and a
;; child represents... well, a child.
;;
;; Often, but not always, family trees represent (a) legally-recognized
;; relationships and (b) relationships in which the children are directly
;; genetically related to their parents. That means that children (or parents!)
;; resulting from any sort of relationship that doesn't meet both conditions (a)
;; and (b) might not be included in a family tree.
;;
;; Over time, ideas about what a "family" is, and about which familial relations
;; should be openly acknowledged and documented have changed. That means that a
;; family tree is both a "biological" record and a cultural one. Determining
;; citizenship (who is a citizen of a nation? who can apply for citizenship
;; based on family relationships?), finances (whose debts are you responsible
;; for paying?), medical decision-making authority (what decisions can someone
;; make on someone else's behalf?), and inheritance (who will automatically
;; inherit if there is no will?) all depend on definitions of who counts as
;; "family" or "relatives".
;;
;; As a result, decisions about who is a member of a family doesn't have only
;; emotional and psychological consequences; it also has political and legal
;; ones. Someone might be subjected to harms or eligible for benefits depending
;; on whether a law or policy considers them to be part of "the same family" as
;; someone else. What our language means, therefore, is quite important.
;;
;; If you had to design a data definition for a family tree, what kinds of
;; relation do you think it should represent? In other words, what counts as
;; "being part of the same family"? Please include a justification of your
;; answer in 2 - 3 sentences.





;;! Problem 2

;;! Part A
;;
;; Design a function called tree-map that takes a function and a binary tree and
;; applies the function to each value in the tree. The function should return a
;; new tree with the same structure as the original tree, but with the values
;; replaced by the result of applying the function to the value that was
;; originally there.

;;!! IMPORTANT: Write your response BELOW this line:


;;! Part B
;;
;; Design a function called tree-andmap that takes a predicate and determines whether all values in the
;; tree satisfy the predicate.

;;!! IMPORTANT: Write your response BELOW this line:



;;! Part C
;;
;; Design a function called tree-ormap that takes a predicate and determines whether any values in the
;; tree satisfy the predicate.

;;!! IMPORTANT: Write your response BELOW this line:


;;! Part D

;; Design a function tree-fold that acts like a fold over a tree. This takes in a function
;; to apply to leaf values, and a function to combine the results of folding subtrees.
;; These two functions should be used to compress a given tree down to
;; a single resulting value. It should have the following signature:

;; tree-fold : (X -> Y) (Y Y -> Y) [BinTree-of X] -> Y

;; where `(X -> Y)` is the function for the leaf, and
;; `(Y Y -> Y)` is the function to combine the results of folding subtrees.

;; A test is provided for clarity.

(check-expect (tree-fold string-upcase string-append
                         (make-node (make-leaf "hello") (make-leaf "world"))) "HELLOWORLD")

;;!! IMPORTANT: Write your response BELOW this line:


;;! Problem 3
;; Now we will use the tree-abstractions we defined in Problem 2 to reimplement the solutions in
;; Problem 1

;;! Part A
;;
;; Reimplement the tree-zero function using tree abstractions from problem 2; call it `tree-zero/v2`

;;!! IMPORTANT: Write your response BELOW this line:


;;! Part B
;;
;; Reimplement the tree-contains? function using tree abstractions from problem 2; call it `tree-contains?/v2`.

;;!! IMPORTANT: Write your response BELOW this line:



;;! Part C
;;
;; Reimplement the tree-sum function using tree abstractions from problem 2; call it `tree-sum/v2`.

;;!! IMPORTANT: Write your response BELOW this line:



;;! Part D
;;
;; Reimplement the tree-flatten function using tree abstractions from problem 2;
;; call it `tree-flatten/v2`.

;;!! IMPORTANT: Write your response BELOW this line:

